// Code generated by protoc-gen-grpc-federation. DO NOT EDIT!
package pluginpb

import (
	"reflect"

	grpcfed "github.com/mercari/grpc-federation/grpc/federation"
)

var (
	_ = reflect.Invalid // to avoid "imported and not used error"
)

type RegexpPlugin interface {
	Example_Regexp_Compile(string) (*Regexp, error)
	Example_Regexp_Regexp_MatchString(*Regexp, string) (bool, error)
}

var (
	reg_RegexpPlugin RegexpPlugin
	mu_RegexpPlugin  grpcfed.RWMutex
)

func RegisterRegexpPlugin(plug RegexpPlugin) {
	mu_RegexpPlugin.Lock()
	defer mu_RegexpPlugin.Unlock()
	reg_RegexpPlugin = plug
}

//export example_regexp_compile_string_example_regexp_Regexp
func example_regexp_compile_string_example_regexp_Regexp(arg0 uint32, arg1 uint32) grpcfed.ReturnValue {
	converted_arg0 := grpcfed.ToString(arg0, arg1)

	mu_RegexpPlugin.RLock()
	ret, err := reg_RegexpPlugin.Example_Regexp_Compile(converted_arg0)
	mu_RegexpPlugin.RUnlock()
	if err != nil {
		return grpcfed.ErrorToReturnValue(err)
	}
	return grpcfed.MessageToReturnValue(ret)
}

//export example_regexp_Regexp_matchString_example_regexp_Regexp_string_bool
func example_regexp_Regexp_matchString_example_regexp_Regexp_string_bool(arg0 uint32, arg1 uint32, arg2 uint32) grpcfed.ReturnValue {
	converted_arg0 := grpcfed.ToMessage[Regexp](arg0)
	converted_arg1 := grpcfed.ToString(arg1, arg2)

	mu_RegexpPlugin.RLock()
	ret, err := reg_RegexpPlugin.Example_Regexp_Regexp_MatchString(converted_arg0, converted_arg1)
	mu_RegexpPlugin.RUnlock()
	if err != nil {
		return grpcfed.ErrorToReturnValue(err)
	}
	return grpcfed.BoolToReturnValue(ret)
}
