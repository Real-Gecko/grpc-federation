{{- define "evalDef" -}}
{{- if .Definition.IsMap -}}
{{- $mapResolver := .Definition.MapResolver -}}
grpcfed.EvalDefMap({{ .Ctx }}, value, grpcfed.DefMap[{{ .Definition.Type }}, {{ $mapResolver.IteratorSourceType }}, *localValueType]{
	{{- if .Definition.UseIf }}
	If: "{{ .Definition.If }}",
	{{- end }}
	Name:   "{{ .Definition.Key }}",
	Type:   {{ .Definition.CELType }},
	Setter: func(value *localValueType, v {{ .Definition.Type }}) { value.vars.{{ .Definition.Key }} = v },
	IteratorName: "{{ $mapResolver.IteratorName }}",
	IteratorType: {{ $mapResolver.IteratorCELType }},
	IteratorSource: {{ $mapResolver.IteratorSource }},
	Iterator: func(ctx context.Context, value *grpcfed.MapIteratorValue) (any, error) {
		{{- if $mapResolver.IsBy }}
		{{- $by := $mapResolver.MapExpr.Expr.By }}
		return grpcfed.EvalCEL(ctx, value, "{{ $by.Expr }}", reflect.TypeOf({{ $mapResolver.IteratorZeroValue }}))
		{{- else if $mapResolver.IsMessage }}
		{{- $arguments := $mapResolver.Arguments }}
		args := &{{ $mapResolver.RequestType }}{
			{{- range $arguments }}
			{{- if not .CEL }}
			{{ .Name }}: {{ .Value }}, {{ .ProtoComment }}
			{{- end }}
			{{- end }}
		}
		{{- range $arguments }}
		{{- if .CEL }}
		{{ .ProtoComment }}
		if err := grpcfed.SetCELValue(ctx, value, "{{ .CEL.Expr }}", func(v {{ .Type }}){
			{{- if ne (len .InlineFields) 0 }}
			{{- range .InlineFields }}
			args.{{ .Name }} = {{ .Value }}
			{{- end }}
			{{- else }}
			args.{{ .Name }} = {{ .Value }}
			{{- end }}
		}); err != nil {
			return nil, err
		}
		{{- end }}
		{{- end }}
		return s.{{ $mapResolver.Caller }}(ctx, args)
		{{- end }}
	},
})
{{- else -}}
grpcfed.EvalDef({{ .Ctx }}, value, grpcfed.Def[{{ .Definition.Type }}, *localValueType]{
	{{- if .Definition.UseIf }}
	If: "{{ .Definition.If }}",
	{{- end }}
	Name:   "{{ .Definition.Key }}",
	Type:   {{ .Definition.CELType }},
	Setter: func(value *localValueType, v {{ .Definition.Type }}) { value.vars.{{ .Definition.Key }} = v },
	{{- if .Definition.IsBy }}
	By:     "{{ .Definition.By.Expr }}",
	{{- else if .Definition.IsValidation }}
	Validation:  func(ctx context.Context, value *localValueType) error {
		{{- template "messageValidation" .Definition.MessageValidation }}
	},
	{{- else }}
	Message: func(ctx context.Context, value *localValueType) (any, error) {
		{{- $arguments := .Definition.Arguments }}
		{{- if .Definition.UseArgs }}
		args := &{{ .Definition.RequestType }}{
			{{- range $arguments }}
			{{- if not .CEL }}
			{{ .Name }}: {{ .Value }}, {{ .ProtoComment }}
			{{- end }}
			{{- end }}
		}
		{{- end }}
		{{- range $arguments }}
		{{- if .CEL }}
		{{ .ProtoComment }}
		if err := grpcfed.SetCELValue(ctx, value, "{{ .CEL.Expr }}", func(v {{ .Type }}){
			{{- if ne (len .InlineFields) 0 }}
			{{- range .InlineFields }}
			args.{{ .Name }} = {{ .Value }}
			{{- end }}
			{{- else }}
			args.{{ .Name }} = {{ .Value }}
			{{- end }}
		}); err != nil {
			return nil, err
		}
		{{- end }}
		{{- end }}
		{{- if .Definition.UseTimeout }}
		return grpcfed.WithTimeout[{{ .Definition.ReturnType }}](ctx, "{{ .Definition.MethodFQDN }}", {{ .Definition.Timeout }}, func(ctx context.Context) (*{{ .Definition.ReturnType }}, error) {
			{{- if .Definition.UseRetry }}
			{{- template "retry" (map "Retry" .Definition.Retry) }}
			return grpcfed.WithRetry[{{ .Definition.ReturnType }}](b, func() (*{{ .Definition.ReturnType }}, error) {
				return s.{{ .Definition.Caller }}(ctx, args)
			})
			{{- else }}
			return s.{{ .Definition.Caller }}(ctx, args)
			{{- end }}
		})
		{{- else if .Definition.UseRetry }}
		{{- template "retry" (map "Retry" .Definition.Retry) }}
		return grpcfed.WithRetry[{{ .Definition.ReturnType }}](b, func() (*{{ .Definition.ReturnType }}, error) {
			return s.{{ .Definition.Caller }}(ctx, args)
		})
		{{- else }}
		return s.{{ .Definition.Caller }}(ctx, args)
		{{- end }}
	},
	{{- end }}
})
{{- end }}
{{- end }}

{{- define "evalMessageDef" }}
// This section's codes are generated by the following proto definition.
/*
{{ .Definition.ProtoComment }}
*/
if err := {{- template "evalDef" (map "Ctx" .Ctx "Definition" .Definition) -}}; err != nil {
	{{- template "errorHandler" (map "Ctx" .Ctx "Definition" .Definition) }}
}
{{- end }}

{{- define "evalDefGroup" }}
{{- if .Definition.IsConcurrent }}
eg, {{ printf "ctx%d" .Level }} := errgroup.WithContext({{ parentCtx .Level }})
{{- range .Definition.Starts }}
grpcfed.GoWithRecover(eg, func() (any, error) {
	{{- template "evalDefGroup" (map "Level" (add $.Level 1) "Definition" .) }}
	return nil, nil
})
{{- end }}
if err := eg.Wait(); err != nil {
	return nil, err
}
{{- if .Definition.ExistsEnd }}
{{ template "evalMessageDef" (map "Ctx" (parentCtx .Level) "Definition" .Definition.End) }}
{{- end }}

{{- else }}

{{- if .Definition.ExistsStart }}
{{ template "evalDefGroup" (map "Level" .Level "Definition" .Definition.Start) }}
{{- end }}

{{- if .Definition.ExistsEnd }}
{{ template "evalMessageDef" (map "Ctx" (parentCtx .Level) "Definition" .Definition.End) }}
{{- end }}

{{- end }}
{{- end }}
