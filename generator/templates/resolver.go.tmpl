{{- define "callResolver" -}}
{{- if .Resolver.IsMap -}}
{{- $mapResolver := .Resolver.MapResolver -}}
grpcfed.EvalDefMap({{ .Ctx }}, value, grpcfed.DefMap[{{ .Resolver.Type }}, {{ $mapResolver.IteratorSourceType }}, *localValueType]{
	{{- if .Resolver.UseIf }}
	If: "{{ .Resolver.If }}",
	{{- end }}
	Name:   "{{ .Resolver.Key }}",
	Type:   {{ .Resolver.CELType }},
	Setter: func(value *localValueType, v {{ .Resolver.Type }}) { value.vars.{{ .Resolver.Key }} = v },
	IteratorName: "{{ $mapResolver.IteratorName }}",
	IteratorType: {{ $mapResolver.IteratorCELType }},
	IteratorSource: {{ $mapResolver.IteratorSource }},
	Iterator: func(ctx context.Context, value *grpcfed.MapIteratorValue) (any, error) {
		{{- if $mapResolver.IsBy }}
		{{- $by := $mapResolver.MapExpr.Expr.By }}
		return grpcfed.EvalCEL(ctx, value, "{{ $by.Expr }}", reflect.TypeOf({{ $mapResolver.IteratorZeroValue }}))
		{{- else if $mapResolver.IsMessage }}
		{{- $arguments := $mapResolver.Arguments }}
		args := &{{ $mapResolver.RequestType }}{
			{{- range $arguments }}
			{{- if not .CEL }}
			{{ .Name }}: {{ .Value }}, {{ .ProtoComment }}
			{{- end }}
			{{- end }}
		}
		{{- range $arguments }}
		{{- if .CEL }}
		{{ .ProtoComment }}
		if err := grpcfed.SetCELValue(ctx, value, "{{ .CEL.Expr }}", func(v {{ .Type }}){
			{{- if ne (len .InlineFields) 0 }}
			{{- range .InlineFields }}
			args.{{ .Name }} = {{ .Value }}
			{{- end }}
			{{- else }}
			args.{{ .Name }} = {{ .Value }}
			{{- end }}
		}); err != nil {
			return nil, err
		}
		{{- end }}
		{{- end }}
		return s.{{ $mapResolver.Caller }}(ctx, args)
		{{- end }}
	},
})
{{- else -}}
grpcfed.EvalDef({{ .Ctx }}, value, grpcfed.Def[{{ .Resolver.Type }}, *localValueType]{
	{{- if .Resolver.UseIf }}
	If: "{{ .Resolver.If }}",
	{{- end }}
	Name:   "{{ .Resolver.Key }}",
	Type:   {{ .Resolver.CELType }},
	Setter: func(value *localValueType, v {{ .Resolver.Type }}) { value.vars.{{ .Resolver.Key }} = v },
	{{- if .Resolver.IsBy }}
	By:     "{{ .Resolver.By.Expr }}",
	{{- else if .Resolver.IsValidation }}
	Validation:  func(ctx context.Context, value *localValueType) error {
		{{- template "messageValidation" .Resolver.MessageValidation }}
	},
	{{- else }}
	Message: func(ctx context.Context, value *localValueType) (any, error) {
		{{- $arguments := .Resolver.Arguments }}
		{{- if .Resolver.UseArgs }}
		args := &{{ .Resolver.RequestType }}{
			{{- range $arguments }}
			{{- if not .CEL }}
			{{ .Name }}: {{ .Value }}, {{ .ProtoComment }}
			{{- end }}
			{{- end }}
		}
		{{- end }}
		{{- range $arguments }}
		{{- if .CEL }}
		{{ .ProtoComment }}
		if err := grpcfed.SetCELValue(ctx, value, "{{ .CEL.Expr }}", func(v {{ .Type }}){
			{{- if ne (len .InlineFields) 0 }}
			{{- range .InlineFields }}
			args.{{ .Name }} = {{ .Value }}
			{{- end }}
			{{- else }}
			args.{{ .Name }} = {{ .Value }}
			{{- end }}
		}); err != nil {
			return nil, err
		}
		{{- end }}
		{{- end }}
		{{- if .Resolver.UseTimeout }}
		return grpcfed.WithTimeout[{{ .Resolver.ReturnType }}](ctx, "{{ .Resolver.MethodFQDN }}", {{ .Resolver.Timeout }}, func(ctx context.Context) (*{{ .Resolver.ReturnType }}, error) {
			{{- if .Resolver.UseRetry }}
			{{- template "retry" (map "Retry" .Resolver.Retry) }}
			return grpcfed.WithRetry[{{ .Resolver.ReturnType }}](b, func() (*{{ .Resolver.ReturnType }}, error) {
				return s.{{ .Resolver.Caller }}(ctx, args)
			})
			{{- else }}
			return s.{{ .Resolver.Caller }}(ctx, args)
			{{- end }}
		})
		{{- else if .Resolver.UseRetry }}
		{{- template "retry" (map "Retry" .Resolver.Retry) }}
		return grpcfed.WithRetry[{{ .Resolver.ReturnType }}](b, func() (*{{ .Resolver.ReturnType }}, error) {
			return s.{{ .Resolver.Caller }}(ctx, args)
		})
		{{- else }}
		return s.{{ .Resolver.Caller }}(ctx, args)
		{{- end }}
	},
	{{- end }}
})
{{- end }}
{{- end }}

{{- define "messageResolver" }}
// This section's codes are generated by the following proto definition.
/*
{{ .Resolver.ProtoComment }}
*/
if err := {{- template "callResolver" (map "Ctx" .Ctx "Resolver" .Resolver) -}}; err != nil {
	{{- template "errorHandler" (map "Ctx" .Ctx "Resolver" .Resolver) }}
}
{{- end }}

{{- define "resolverGroup" }}
{{- if .Resolver.IsConcurrent }}
eg, {{ printf "ctx%d" .Level }} := errgroup.WithContext({{ parentCtx .Level }})
{{- range .Resolver.Starts }}
grpcfed.GoWithRecover(eg, func() (any, error) {
	{{- template "resolverGroup" (map "Level" (add $.Level 1) "Resolver" .) }}
	return nil, nil
})
{{- end }}
if err := eg.Wait(); err != nil {
	return nil, err
}
{{- if .Resolver.ExistsEnd }}
{{ template "messageResolver" (map "Ctx" (parentCtx .Level) "Resolver" .Resolver.End) }}
{{- end }}

{{- else }}

{{- if .Resolver.ExistsStart }}
{{ template "resolverGroup" (map "Level" .Level "Resolver" .Resolver.Start) }}
{{- end }}

{{- if .Resolver.ExistsEnd }}
{{ template "messageResolver" (map "Ctx" (parentCtx .Level) "Resolver" .Resolver.End) }}
{{- end }}

{{- end }}
{{- end }}
